#! /usr/bin/env python

"""Dipolar Lattice Builder

Creates cubic lattices of dipoles to test the dipole-dipole
interaction code.  

Usage: buildDipolarArray 

Options:
  -h, --help              show this help
  -x, --array-type-X      use one of the basic "X" arrays
  -y, --array-type-Y      use one of the basic "Y" arrays
  -z, --array-type-Z      use one of the basic "Z" arrays
  -a, --array-type-A      use array type "A" (default)
  -b, --array-type-B      use array type "B"
  -l, --lattice=...       use the specified lattice ( SC, FCC, or BCC )
  -d, --direction=...     use dipole orientation (001, 111, or 011)
  -c, --constant=...      use the specified lattice constant
  -n                      use the specified number of unit cells
  -o, --output-file=...   use specified output (.xyz) file

Type "A" arrays have nearest neighbor strings of antiparallel dipoles.

Type "B" arrays have nearest neighbor strings of antiparallel dipoles
if the dipoles are contained in a plane perpendicular to the dipole
direction that passes through the dipole.

Example:
   buildDipolarArray -a -l fcc -d 001 -c 5 -n 3 -o A_fcc_001.xyz

"""

__author__ = "Dan Gezelter (gezelter@nd.edu)"
__version__ = "$Revision: 1639 $"
__date__ = "$Date: 2011-09-24 16:18:07 -0400 (Sat, 24 Sep 2011) $"

__copyright__ = "Copyright (c) 2013 by the University of Notre Dame"
__license__ = "OpenMD"

import sys
import getopt
import string
import math
import numpy

def usage():
    print __doc__

    
    
def createLattice(latticeType, latticeNumber, latticeConstant, dipoleDirection, arrayType, outputFileName):
    # The following section creates 24 basic arrays from Luttinger and
    # Tisza:

    # The six unit vectors are: 3 spatial and 3 to describe the
    # orientation of the dipole.
    
    e1 = numpy.array([1.0,0.0,0.0,0.0,0.0,0.0])
    e2 = numpy.array([0.0,1.0,0.0,0.0,0.0,0.0])
    e3 = numpy.array([0.0,0.0,1.0,0.0,0.0,0.0])
    e4 = numpy.array([0.0,0.0,0.0,1.0,0.0,0.0])
    e5 = numpy.array([0.0,0.0,0.0,0.0,1.0,0.0])
    e6 = numpy.array([0.0,0.0,0.0,0.0,0.0,1.0])

    # Parameters describing the 8 basic arrays:
    cell = numpy.array([[0,0,0],[0,0,1],[1,0,0],[0,1,0],
                        [1,1,0],[0,1,1],[1,0,1],[1,1,1]])

    X = numpy.zeros(384).reshape((8,8,6))
    Y = numpy.zeros(384).reshape((8,8,6))
    Z = numpy.zeros(384).reshape((8,8,6))
    # mX, mY, and mZ arrays have dipole direction flipped
    mX = numpy.zeros(384).reshape((8,8,6))
    mY = numpy.zeros(384).reshape((8,8,6))
    mZ = numpy.zeros(384).reshape((8,8,6))

    # create the 24 basic arrays using Eq. 12 in Luttinger & Tisza:
    for i in range(8):
        which = 0
        for l1 in range(2):
            for l2 in range(2):
                for l3 in range(2):
                    lvals = numpy.array([l1,l2,l3])
                    value = math.pow(-1, numpy.dot(cell[i], lvals))
                    Xvec = (l1*e1 + l2*e2 + l3*e3) + value * e4             
                    Yvec = (l1*e1 + l2*e2 + l3*e3) + value * e5             
                    Zvec = (l1*e1 + l2*e2 + l3*e3) + value * e6             
                    mXvec = (l1*e1 + l2*e2 + l3*e3) - value * e4             
                    mYvec = (l1*e1 + l2*e2 + l3*e3) - value * e5             
                    mZvec = (l1*e1 + l2*e2 + l3*e3) - value * e6             
                    X[i][which] = Xvec
                    Y[i][which] = Yvec
                    Z[i][which] = Zvec
                    mX[i][which] = mXvec
                    mY[i][which] = mYvec
                    mZ[i][which] = mZvec
                    which = which + 1

    # The simple cubic array has only one site at the lattice point:
    lp = numpy.array([0.0,0.0,0.0,0.0,0.0,0.0])

    # The body-centered cubic array also has a body-centerered site:
    bc = numpy.array([0.5,0.5,0.5,0.0,0.0,0.0])

    # The face-centered cubic array also has 3 face-centered sites:
    xy = numpy.array([0.5,0.5,0.0,0.0,0.0,0.0])
    yz = numpy.array([0.0,0.5,0.5,0.0,0.0,0.0])
    xz = numpy.array([0.5,0.0,0.5,0.0,0.0,0.0])

    sc =      numpy.array([[0.0,0.0,0.0]])

    bcc =     numpy.array([[0.0,0.0,0.0],
                           [0.5,0.5,0.5]])

    fcc =     numpy.array([[0.0,0.0,0.0], 
                           [0.5,0.5,0.0],
                           [0.0,0.5,0.5],
                           [0.5,0.0,0.5]])

    known_case = False

    if (arrayType == 'X'):
        if (int(latticeType)):
            which = int(latticeType) - 1
            basic_array = X[which]
            known_case = True
    if (arrayType == 'Y'):
        if (int(latticeType)):
            which = int(latticeType) - 1
            basic_array = Y[which]
            known_case = True
    if (arrayType == 'Z'):
        if (int(latticeType)):
            which = int(latticeType) - 1 
            basic_array = Z[which]
            known_case = True
    if (arrayType == 'A'):
        if (latticeType.lower() == 'sc'):
            basic_array = Z[5]+lp
            known_case = True
        if (latticeType.lower() == 'bcc'):
            if (dipoleDirection.lower() == '001'):
                basic_array = numpy.append(Z[1]+lp, mZ[1]+bc, axis=0)
                known_case = True
            if (dipoleDirection.lower() == '111'):
                basic_array = numpy.append(Z[5]+X[7]+Y[6]+lp,
                                           Z[5]+X[7]+Y[6]+bc, axis=0)
                known_case = True
        if (latticeType.lower() == 'fcc'):
            if (dipoleDirection.lower() == '001'):
                basic_array = numpy.append(Z[1]+lp,  Z[1]+xy, axis=0)
                basic_array = numpy.append(basic_array, mZ[1]+yz, axis=0) 
                basic_array = numpy.append(basic_array, mZ[1]+xz, axis=0) 
                known_case = True
            if (dipoleDirection.lower() == '011'):
                basic_array = numpy.append(Z[1]+Y[1]+lp, Z[1]+Y[1]+yz, axis=0)
                basic_array = numpy.append(basic_array, mZ[1]+mY[1]+xy, axis=0)
                basic_array = numpy.append(basic_array, mZ[1]+mY[1]+xz, axis=0) 
                known_case = True
    else:
        if (latticeType.lower() == 'sc'):
            basic_array = Z[5]+lp
            known_case = True
        if (latticeType.lower() == 'bcc'):
            if (dipoleDirection.lower() == '001'):
                basic_array = numpy.append(Z[5]+lp, mZ[5]+bc, axis=0)
                known_case = True
            if (dipoleDirection.lower() == '111'):
                basic_array = numpy.append(Z[5]+X[7]+Y[6]+lp,
                                           Z[5]+X[7]+Y[6]+bc, axis=0)
                known_case = True
        if (latticeType.lower() == 'fcc'):
            if (dipoleDirection.lower() == '001'):
                basic_array = numpy.append(Z[1]+lp,  Z[1]+yz, axis=0)
                basic_array = numpy.append(basic_array, mZ[1]+xy, axis=0) 
                basic_array = numpy.append(basic_array, mZ[1]+xz, axis=0) 
                known_case = True
            if (dipoleDirection.lower() == '011'):
                basic_array = numpy.append(Z[8]+Y[8]+lp, Z[8]+Y[8]+xy, axis=0)
                basic_array = numpy.append(basic_array, Z[8]+Y[8]+yz, axis=0)
                basic_array = numpy.append(basic_array, mZ[8]+mY[8]+xz, axis=0) 
                known_case = True

    if (not known_case):
        print "unhandled combination of lattice and dipole direction"
        print __doc__

    print basic_array

    bravais_lattice = []
    for i in range(latticeNumber):
        for j in range(latticeNumber):
            for k in range(latticeNumber):
                for l in range(len(basic_array)):
                    bravais_lattice.append(2*i*e1 + 2*j*e2 + 2*k*e3 + basic_array[l])

    outputFile = open(outputFileName, 'w')
    
    outputFile.write('<OpenMD version=2>\n')
    outputFile.write('  <MetaData>\n')
    outputFile.write('     molecule{\n')
    outputFile.write('       name = \"D\";\n')
    outputFile.write('       \n')
    outputFile.write('       atom[0]{\n')
    outputFile.write('         type = \"D\";\n')
    outputFile.write('         position(0.0, 0.0, 0.0);\n')
    outputFile.write('         orientation(0.0, 0.0, 0.0);\n')
    outputFile.write('       }\n')
    outputFile.write('     }\n')
    outputFile.write('     component{\n')
    outputFile.write('       type = \"D\";\n')
    outputFile.write('       nMol = '+ repr(len(bravais_lattice)) + ';\n')
    outputFile.write('     }\n')

    outputFile.write('     ensemble = NVE;\n')
    outputFile.write('     forceField = \"Multipole\";\n')

    outputFile.write('     cutoffMethod = \"shifted_force\";\n')
    outputFile.write('     electrostaticScreeningMethod = \"damped\";\n')

    outputFile.write('     cutoffRadius = 9.0;\n')
    outputFile.write('     dampingAlpha = 0.18;\n')
    outputFile.write('     statFileFormat = \"TIME|TOTAL_ENERGY|POTENTIAL_ENERGY|KINETIC_ENERGY|TEMPERATURE|PRESSURE|VOLUME|CONSERVED_QUANTITY|ELECTROSTATIC_POTENTIAL\";\n')
    outputFile.write('     dt = 1.0;\n')
    outputFile.write('     runTime = 1.0;\n')
    outputFile.write('     sampleTime = 1.0;\n')
    outputFile.write('     statusTime = 1.0;\n')
    outputFile.write('  </MetaData>\n')
    outputFile.write('  <Snapshot>\n')
    outputFile.write('    <FrameData>\n');
    outputFile.write("        Time: %.10g\n" % (0.0))
    
    Hxx = 2.0 * latticeConstant * latticeNumber
    Hyy = 2.0 * latticeConstant * latticeNumber
    Hzz = 2.0 * latticeConstant * latticeNumber
    
    outputFile.write('        Hmat: {{%d, 0, 0}, {0, %d, 0}, {0, 0, %d}}\n' % (Hxx, Hyy, Hzz))
    outputFile.write('    </FrameData>\n')
    outputFile.write('    <StuntDoubles>\n')
    sdFormat = 'pvqj'
    index = 0
    
    for i in range(len(bravais_lattice)):
        xcart = latticeConstant*(bravais_lattice[i][0])
        ycart = latticeConstant*(bravais_lattice[i][1])
        zcart = latticeConstant*(bravais_lattice[i][2])
        dx = bravais_lattice[i][3]
        dy = bravais_lattice[i][4]
        dz = bravais_lattice[i][5]

        uz = numpy.array([dx, dy, dz])
        uz = uz/numpy.linalg.norm(uz)
        
        uy = numpy.array([0.0, 1.0, 0.0])
        uy = uy - uz * numpy.vdot(uy, uz) / numpy.vdot(uz, uz) 
        uy = uy/numpy.linalg.norm(uy)

        ux = numpy.cross(uy, uz)

        RotMat = [ux, uy, uz]

        q = [0.0, 0.0, 0.0, 0.0]

        # RotMat to Quat code is out of OpenMD's SquareMatrix3.hpp code:

        t = RotMat[0][0] + RotMat[1][1] + RotMat[2][2] + 1.0
        
        if( t > 1e-6 ):
            s = 0.5 / math.sqrt( t )
            q[0] = 0.25 / s
            q[1] = (RotMat[1][2] - RotMat[2][1]) * s
            q[2] = (RotMat[2][0] - RotMat[0][2]) * s
            q[3] = (RotMat[0][1] - RotMat[1][0]) * s
        else:
            ad1 = RotMat[0][0]
            ad2 = RotMat[1][1]
            ad3 = RotMat[2][2]

            if( ad1 >= ad2 and ad1 >= ad3 ):
                s = 0.5 / math.sqrt( 1.0 + RotMat[0][0] - RotMat[1][1] - RotMat[2][2] )
                q[0] = (RotMat[1][2] - RotMat[2][1]) * s
                q[1] = 0.25 / s
                q[2] = (RotMat[0][1] + RotMat[1][0]) * s
                q[3] = (RotMat[0][2] + RotMat[2][0]) * s
            elif ( ad2 >= ad1 and ad2 >= ad3 ):
                s = 0.5 / math.sqrt( 1.0 + RotMat[1][1] - RotMat[0][0] - RotMat[2][2] )
                q[0] = (RotMat[2][0] - RotMat[0][2] ) * s
                q[1] = (RotMat[0][1] + RotMat[1][0]) * s
                q[2] = 0.25 / s
                q[3] = (RotMat[1][2] + RotMat[2][1]) * s
            else:
                s = 0.5 / math.sqrt( 1.0 + RotMat[2][2] - RotMat[0][0] - RotMat[1][1] )
                q[0] = (RotMat[0][1] - RotMat[1][0]) * s
                q[1] = (RotMat[0][2] + RotMat[2][0]) * s
                q[2] = (RotMat[1][2] + RotMat[2][1]) * s
                q[3] = 0.25 / s

        
        outputFile.write("%10d %7s %18.10g %18.10g %18.10g %13e %13e %13e %13e %13e %13e %13e %13e %13e %13e\n" % (index, sdFormat, xcart, ycart, zcart, 0.0, 0.0, 0.0, q[0], q[1], q[2], q[3], 0.0, 0.0, 0.0))
        index = index+1

    outputFile.write("    </StuntDoubles>\n")
    outputFile.write("  </Snapshot>\n")
    outputFile.write("</OpenMD>\n")
    outputFile.close()

    outputFile.close()
    
def main(argv):
    
    arrayType = "A"
    haveOutputFileName = False
    latticeType = "fcc"
    dipoleDirection = "001"
    latticeNumber = 3
    latticeConstant = 4
    try:                                
        opts, args = getopt.getopt(argv, "hxyzabl:d:c:n:o:", ["help","array-type-X", "array-type-Y", "array-type-Z", "array-type-A", "array-type-B", "lattice=" "direction=", "constant=", "output-file="])  
    except getopt.GetoptError:           
        usage()                          
        sys.exit(2)                     
    for opt, arg in opts:                
        if opt in ("-h", "--help"):      
            usage()                     
            sys.exit()
        elif opt in ("-x", "--array-type-X"):
            arrayType = "X"
        elif opt in ("-y", "--array-type-Y"):
            arrayType = "Y"
        elif opt in ("-z", "--array-type-Z"):
            arrayType = "Z"
        elif opt in ("-b", "--array-type-B"):
            arrayType = "B"
        elif opt in ("-l", "--lattice"): 
            latticeType = arg
        elif opt in ("-d", "--direction"):
            dipoleDirection = arg
        elif opt in ("-c", "--constant"):
            latticeConstant = float(arg)
        elif opt in ("-n"):
            latticeNumber = int(arg)
        elif opt in ("-o", "--output-file"): 
            outputFileName = arg
            haveOutputFileName = True
    if (not haveOutputFileName):
        usage()
        print "No output file was specified"
        sys.exit()
        
    createLattice(latticeType, latticeNumber, latticeConstant, dipoleDirection, arrayType, outputFileName);

if __name__ == "__main__":
    if len(sys.argv) == 1:
        usage()
        sys.exit()
    main(sys.argv[1:])
